use std::{
    fmt::Write as _,
    fs::File,
    io::{BufReader, Cursor, Read, Seek, SeekFrom, Write},
    path::{Path, PathBuf},
};

use anyhow::Context;
use serde::{Deserialize, Serialize};
use sha2::Digest;
use tar::EntryType;

#[derive(Clone, Debug, Deserialize, Serialize)]
struct Manifest {
    #[serde(rename = "RepoTags")]
    repo_tags: Vec<String>,
    #[serde(rename = "Config")]
    config: String,

    #[serde(rename = "Layers")]
    layers: Vec<String>,

    #[serde(flatten)]
    extra_fields: serde_json::Value,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
struct Rootfs {
    #[serde(rename = "type")]
    type_: String,

    diff_ids: Vec<String>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
struct ImageConfiguration {
    config: serde_json::Value,

    rootfs: Rootfs,

    #[serde(flatten)]
    extra_fields: serde_json::Value,
}

/// Configuration generated by streamLayeredImage
#[derive(Clone, Debug, Deserialize)]
struct StreamLayeredImageConf {
    config: serde_json::Value,
    repo_tag: String,
    customisation_layer: String,
}

#[derive(Debug)]
struct Args {
    /// Path to configuration generated by streamLayeredImage
    conf: String,
    /// Path to existing image that will be used as base
    base_image: String,

    /// Path to write output image
    output: Option<String>,
}

fn parse_args() -> Result<Args, lexopt::Error> {
    use lexopt::prelude::*;

    let mut conf = None;
    let mut base_image = None;
    let mut output = None;
    let mut parser = lexopt::Parser::from_env();
    while let Some(arg) = parser.next()? {
        match arg {
            Short('c') | Long("conf") => conf = Some(parser.value()?.string()?),
            Short('o') | Long("output") => output = Some(parser.value()?.string()?),
            Value(val) if base_image.is_none() => {
                base_image = Some(val.string()?);
            }
            Long("help") => {
                println!("Usage: unlayer [-c|--conf=CONF] [-o|--output=OUTPUT] BASE_IMAGE");
                std::process::exit(0);
            }
            _ => return Err(arg.unexpected()),
        }
    }

    Ok(Args {
        conf: conf.ok_or("missing argument CONF")?,
        base_image: base_image.ok_or("missing argument BASE_IMAGE")?,
        output,
    })
}

fn extract_json<R: Read + Seek, O: serde::de::DeserializeOwned>(
    input_file: &mut R,
    file_name: &str,
) -> anyhow::Result<O> {
    let mut archive = tar::Archive::new(input_file);
    for entry in archive.entries_with_seek()? {
        let entry = entry?;
        let path = entry.path()?;

        let Some(name) = path.file_name().and_then(|path| path.to_str()) else {
            continue;
        };

        if name != file_name {
            continue;
        }

        let output: O = serde_json::from_reader(entry)?;
        let input_file = archive.into_inner();
        input_file.seek(SeekFrom::Start(0))?;

        return Ok(output);
    }

    anyhow::bail!("Failed to find {} in provided archive", file_name)
}

fn extract_manifest(reader: &mut BufReader<File>) -> anyhow::Result<Manifest> {
    let manifests: Vec<Manifest> = extract_json(reader, "manifest.json")?;
    if manifests.len() != 1 {
        anyhow::bail!("expected exactly 1 manifest, got {}", manifests.len());
    };

    let [manifest] = manifests.try_into().expect("exactly one manifest");
    Ok(manifest)
}

fn add_customisation_layer<W: Write>(
    builder: &mut tar::Builder<W>,
    customisation_path: &str,
) -> anyhow::Result<(String, PathBuf)> {
    let customisation_path = Path::new(&customisation_path);
    let checksum_path = customisation_path.join("checksum");

    let layer_path = customisation_path.join("layer.tar");

    let checksum = std::fs::read_to_string(checksum_path)?;
    let checksum = checksum.trim();

    if checksum.len() != 64 {
        anyhow::bail!("invalid checksum");
    }

    let mut destination_path = Path::new(&checksum).to_owned();
    destination_path.push("layer.tar");

    builder.append_path_with_name(layer_path, &destination_path)?;

    Ok((checksum.to_owned(), destination_path))
}

fn add_image_configuration<W: Write>(
    image_config: ImageConfiguration,
    output_archive: &mut tar::Builder<W>,
) -> anyhow::Result<String> {
    let new_config_bytes = serde_json::to_vec(&image_config)?;
    let new_config_digest = sha2::Sha256::digest(&new_config_bytes);

    let mut new_config_name = String::new();
    for byte in &new_config_digest {
        write!(&mut new_config_name, "{:02x}", byte).expect("writing to string doesn't fail")
    }
    new_config_name.push_str(".json");

    let mut header = tar::Header::new_ustar();
    header.set_entry_type(EntryType::file());
    header.set_path(&new_config_name)?;

    let size: u64 = new_config_bytes.len().try_into()?;
    header.set_size(size);
    header.set_cksum();

    let reader = Cursor::new(&new_config_bytes);
    output_archive.append(&header, reader)?;
    Ok(new_config_name)
}

fn add_manifest<W: Write>(
    manifest: Manifest,
    output_archive: &mut tar::Builder<W>,
) -> anyhow::Result<()> {
    let new_manifest_bytes = serde_json::to_vec(&[&manifest])?;

    let mut header = tar::Header::new_ustar();
    header.set_entry_type(EntryType::file());
    header.set_path("manifest.json")?;

    let size: u64 = new_manifest_bytes.len().try_into()?;
    header.set_size(size);
    header.set_cksum();

    let reader = Cursor::new(&new_manifest_bytes);
    output_archive.append(&header, reader)?;
    Ok(())
}

fn main() -> anyhow::Result<()> {
    // To avoid duplicate error messages for argument parsing specifically this error is handled
    // manually so the source error is erased
    let args = match parse_args() {
        Ok(args) => args,
        Err(e) => anyhow::bail!("{e}"),
    };

    // Read configuration generated by streamLayeredImage
    let stream_config: StreamLayeredImageConf = {
        let reader =
            BufReader::new(File::open(args.conf).context("error opening stream config file")?);

        serde_json::from_reader(reader).context("error parsing stream config")?
    };

    // Read the manifest and image configuration from the base image
    let mut base_reader =
        BufReader::new(File::open(&args.base_image).context("error opening base image")?);

    let mut manifest =
        extract_manifest(&mut base_reader).context("error reading image manifest")?;
    let old_config = manifest.config;

    let mut image_config: ImageConfiguration =
        extract_json(&mut base_reader, &old_config).context("error reading image configuration")?;

    let mut base_archive = tar::Archive::new(base_reader);

    let mut output_archive = {
        let writer: Box<dyn Write> = match args.output {
            Some(path) => Box::new(File::create(&path).context("error creating output file")?),
            None => Box::new(std::io::stdout().lock()),
        };
        tar::Builder::new(writer)
    };

    // Copy base image into the output archive, but skip the manifest and image config
    // as they will be updated
    for entry in base_archive
        .entries_with_seek()
        .context("error reading base image entries")?
    {
        let entry = entry.context("error reading base image entry")?;

        let path = entry.path()?;

        match path.file_name().and_then(|path| path.to_str()) {
            Some("manifest.json") => {}
            Some(file) if file == old_config => {}
            _ => {
                let header = entry.header().clone();
                output_archive.append(&header, entry)?;
            }
        }
    }

    // Add customisation layer from streamLayeredImage so commands can be found in $PATH
    let (customisation_checksum, customisation_path) =
        add_customisation_layer(&mut output_archive, &stream_config.customisation_layer)
            .context("error adding customisation layer to output archive")?;

    // Add back updated image configuration and manifests
    image_config.config = stream_config.config;
    image_config
        .rootfs
        .diff_ids
        .push(format!("sha256:{}", customisation_checksum));

    let new_config_name = add_image_configuration(image_config, &mut output_archive)
        .context("error adding image configuration to output archive")?;

    manifest.config = new_config_name;
    manifest.repo_tags = vec![stream_config.repo_tag];

    let customisation_path = customisation_path.to_str().ok_or(anyhow::anyhow!(
        "customisation layer path is not valid UTF-8"
    ))?;

    manifest.layers.push(customisation_path.to_owned());

    add_manifest(manifest, &mut output_archive)
        .context("error adding manifest to output archive")?;

    output_archive
        .finish()
        .context("error finishing output archive")?;

    Ok(())
}
